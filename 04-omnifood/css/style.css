/*
ALL FOR CONSISTENCY 

---- 01 TYPOGRAPHY SYSTEM ----

- Font sizes (px):
10 / 12 / 14 / 16 / 18 / 20 / 24 / 30 / 36 / 44 / 52 / 62 / 74 / 86 / 98

- Font weights:
Default: 400


- Line heights:
Default: 1

---- 02 COLORS ----

- Primary: #e67e22
- Tints: #fdf2e9;
- Shades:
- Accents:
- Greys: #555; #333;

---- 03 IMAGES - unsplash ----
---- 04 ICONS ----

---- 05 SHADOWS ----

---- 06 BORDER-RADIUS ----

---- 07 WHITESPACE ----
- Spacing system (px)
2 / 4 / 8 / 12 / 16 / 24 / 32 / 48 / 64 / 80 / 96 / 128
*/

/* -------------------------- */

/* First general style - after we might change the font-family and the other rules */

* {
  padding: 0;
  margin: 0;
  box-sizing: border-box;
}

html {
  /* font-size: 10px; */
  /* 10px / 16px = 0.625 === 62.5% */
  /* font-size: 62.5%; */
  /* font-size: 10px; Impossible to change the font size in the browser */
  /* 10px / 16px = 0.625 --> *100 = 62.5 */
  font-size: 62.5%;
  /* Like this we respect the scales and use the trick to facilitate the math */
}
body {
  font-family: sans-serif;
  line-height: 1;
  font-weight: 400;
  color: #555;
}

/* -------------------------- */

.section-hero {
  background-color: #fdf2e9;
  padding: 9.8rem 0;
}

/* Grid layout for the hero */
.hero {
  max-width: 130rem;
  display: grid;
  grid-template-columns: 1fr 1fr;
  margin: 0 auto;
  align-items: center;
  gap: 9.6rem;
}

.heading-primary {
  font-size: 5.2rem;
  font-weight: 700;
  line-height: 1.05;
  color: #333;
  letter-spacing: -0.5px; /* For small distances we can keep using px */
  margin-bottom: 3.2rem;
}

.hero-description {
  font-size: 2rem;
  line-height: 1.6;
  margin-bottom: 4.8rem;
}

.btn:link,
.btn:visited {
  display: inline-block;
  font-size: 2rem;
  text-decoration: none;
  padding: 1.6rem 3.2rem;
  border-radius: 9px;
  /* Css animation -  has to be placed in the rule that has the original state. the first value is for the properties that we want to animate, the second is for how much time. The third is the type of the animation */

  transition: background-color 0.3s;
}

.btn--full:link,
.btn--full:visited {
  background-color: #e67e22;
  color: #fff;
}
.btn--full:hover,
.btn--full:active {
  background-color: #cf711f;
  color: #fff;
}
.btn--outline:link,
.btn--outline:visited {
  background-color: #fff;
  color: #555;
}
.btn--outline:hover,
.btn--outline:active {
  background-color: #fdf2e9;
  color: #555;
  /* border: 3px solid #fff; We can't add a border like this because all the content moves when the button is hovered. For this we use a trick with box shadow to add the border inside: */
  box-shadow: inset 0 0 0 3px #fff; /* We don't have the inset keyword of border */
}
.hero-img {
  width: 100%;
}

/* Helper class - so that we don't have to wrap both buttons in a flex div and add a gap. REMEMBER THAT WE ALSO SHOULD'T ADD THE MARGIN TO THE BUTTON ITSELF BECAUSE WE MIGHT USE IT FURTHER AHEAD */

/* When we use a helper class, we usually want that the style that it has always gets applied, no matter other that are already on the element- !important */
.margin-right-sm {
  margin-right: 1.6rem !important;
}
/*
Things to take:

- Responsive design. There are essentially four ingredients to responsive designs:

01 - Fluid layouts - (flex and css grid) to allow the webpage to adapt to the current viewport width (or even height). Use % or vh/vw instead of px for elements that SHOULD adapt to the viewport. Also use max-width instead of width.


02 - Responsive units - REM instead of px for most lengths (conversion trick - set 1rem to 10px).


03 - Flexible images - By default, images behave different text, they don't scale automatically as we change the viewport. Always use % for image dimensions, together with max.width.


04 - Media queries - This is what brings all the other ingredients together and brings responsive sites to life. Media queries allow us to change styles on certain viewport widths (called breakpoints). Media queries allow developers to create different version of the site for different types of devices (different width).
We only use them at the end.

5 - Why we need a container flex to set a fixed size (so we can have a background color on the parent that occupies all the section)

6 - px to rems

7 - Trick to fake a inset border in the button with box-shadow

8 - The button animation.

9 - The helper function and the highest priority with the !important keyword. It is very common to use with margins that we don't want to apply directly on the elements in order to avoid conflict when we reuse them.
*/

/*
Max-width and rem 

- 1. width - When we use width with a value (1000px as in the example, the element will always stay that wide, if we collapse the page a horizontal scroll bar appears precisely because of that.)

- 2. Max-width - if there is no more space to fit the container, the element should have the width of the parent container (body in this example). Like this it gets smaller after its width doesn't fit. This makes the element flexible to the viewport width.
Notice the difference if we used percentages, the element would then occupy the hole viewport always, but we want it to just have 1000px if the viewport gets bigger. 

3. REM - Root Element font size. The root of the document is the html element (parent to all the others).
If we don't define any font-size on the html element, one rem is equal to the default browser font-size, which is 16px (unless the user changes it).
So, in our example, if 1rem is 16px, 50 rem will be 800px.
In the computed bar of the inspector we can see the rems in px.
---> this will be handy when we build responsive layouts, because we only have to change the font-size in the html.
TRICK - In order of facilitating the math, we can set the font-size to 10px in the html, so that 1rem is 10, 5rem is 50 etc. But we don't do it with pixels, otherwise the users would not be able to change the font-size (accessibility). 

Instead we 

.test {
  background-color: red;
  max-width: 50rem;
  padding: 4rem;
  font-size: 2rem;
  color: #fff;
}
*/
